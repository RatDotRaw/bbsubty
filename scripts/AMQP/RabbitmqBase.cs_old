using Godot;
using System;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using RabbitMQ.Client.Exceptions;

[GlobalClass]
public partial class RabbitmqBase : Node
{
	// Configuration properties
	[Export] public string ExchangeName { get; set; } = string.Empty;
	// [Export] public string ExchangeType { get; set; } = "topic";
	[Export] public bool UseNamedQueue { get; set; } = false;
	[Export] public string QueueName { get; set; } = string.Empty;
	[Export] public string RoutingKey { get; set; } = "#";
	// [Export] public bool DeclareExchange { get; set; } = false;
	[Export] public bool AutoAck { get; set; } = true;

	// Event for message handling
	[Signal] public delegate void MessageReceivedEventHandler(string routingKey, string messageContent);

	private IChannel _channel;
	private Thread _consumerThread;
	private bool _isRunning = false;

	public override void _Ready()
	{
		AMQPConn.Instance.ConnectionEstablished += OnConnectionEstablished;
	}

	private void OnConnectionEstablished()
	{
		GD.Print("AMQP connection established, starting consumer");
		_isRunning = true;
		_consumerThread = new Thread(Consume);
		_consumerThread.Start();
	}

	private async void Consume()
	{
		GD.Print($"Starting consumer for exchange: {ExchangeName}, routing key: {RoutingKey}");
		var amqp = AMQPConn.Instance.AmqpConnection;

		try 
		{
			_channel = await amqp.CreateChannelAsync();

			// // Optionally declare the exchange
			// if (DeclareExchange && !string.IsNullOrEmpty(ExchangeName))
			// {
			//     await _channel.ExchangeDeclareAsync(
			//         exchange: ExchangeName,
			//         type: ExchangeType,
			//         durable: true,
			//         autoDelete: false
			//     );
			// }

			// Declare queue - either named or server-generated
			string actualQueueName;
			if (UseNamedQueue && !string.IsNullOrEmpty(QueueName)) // 
			{
				var queueDeclareResult = await _channel.QueueDeclareAsync(
					queue: QueueName,
					durable: true,
					exclusive: false,
					autoDelete: true
				);
				actualQueueName = queueDeclareResult.QueueName;

			}
			else
			{
				var queueDeclareResult = await _channel.QueueDeclareAsync();
				actualQueueName = queueDeclareResult.QueueName;
			}
			GD.Print($"Created queue: {actualQueueName}");
		}
		catch (Exception ex)
		{
			GD.PrintErr($"Failed to declare queue '{QueueName}': {ex.Message}");
			return;
		}

		// Bind the queue to the exchange with routing key if exchange is provided
		if (!string.IsNullOrEmpty(ExchangeName))
		{
			try
			{
				await _channel.QueueBindAsync(
					queue: actualQueueName,
					exchange: ExchangeName,
					routingKey: RoutingKey
				);
				GD.Print($"Queue bound to exchange: {ExchangeName} with routing key: {RoutingKey}");
			}
			catch (Exception ex)
			{
				string error = $"Failed to bind queue to exchange '{ExchangeName}': {ex.Message}";
				GD.PrintErr(error);
				// CallDeferred(nameof(EmitConsumerError), error);
				return;
			}
		}

		// Declare a basic consumer for the queue
		var consumer = new AsyncEventingBasicConsumer(_channel);
		consumer.ReceivedAsync += OnMessageReceived;

		// Start consuming messages from the queue
		await _channel.BasicConsumeAsync(
			queue: actualQueueName,
			autoAck: AutoAck,
			consumer: consumer
		);
	}

	private Task OnMessageReceived(object model, BasicDeliverEventArgs ea)
	{
		if (!_isRunning) return Task.CompletedTask;

		var body = ea.Body.ToArray();
		var message = Encoding.UTF8.GetString(body);
		var routingKey = ea.RoutingKey;

		// GD.Print("message received:", routingKey);

		// Process the message on the main thread
		CallDeferred(nameof(EmitMessageReceived), routingKey, message);

		if (!AutoAck)
		{
			_channel.BasicAckAsync(ea.DeliveryTag, false);
		}

		return Task.CompletedTask;
	}

	private void EmitMessageReceived(string routingKey, string message)
	{
		EmitSignal(SignalName.MessageReceived, routingKey, message);
	}

	public override void _ExitTree()
	{
		_isRunning = false;
		_channel?.CloseAsync();
		_consumerThread?.Join(1000); // Wait up to 1 second for thread to finish
	}
}
